# volatile为什么不能保证原子性

示例代码

- 循环开启20个线程，并每个线程执行1000个number++，期望结果为20000

- 结果大概率是低于20000

```
    public static int number = 0;

    /**
     * 开启20个线程，并每个线程执行1000个number++，期望结果为20000
     */
    public static void main(String[] args) {
        for(int i = 0; i < 20; i++){
            new Thread(() -> {
                for(int y = 0; y < 1000; y++){
                    number++;
                }
            }, String.valueOf(i)).start();
        }
        //  需要等待上面20个线程都全部完成后，再用main线程取得最终值，原子性合理的情况是20000
        while(Thread.activeCount() > 2){
            Thread.yield();
        }
        System.out.println(Thread.currentThread().getName() + " finally number value:" + number);
    }
```

![number++的字节码操作](https://image-show.oss-cn-shenzhen.aliyuncs.com/typora_img/image-20210304231150938.png)



> 原因：
>
> i++,实际上在底层字节码操作指令里面是4条指令
>
> 第一条指令 getfield  ：取出n这个元素
>
> 第二条指令 iconst_1 ：把常量1压入栈
>
> 第三条指令 iadd ：把n和常量1进行相加
>
> 第四条指令 putfield ：把数据刷回主内存
>
> 在多线程的时候，我们会出现所有线程同时执行了第一条指令，取出了相同的n，也就是0
>
> 然后各自在自己的工作内存中进行加1的操作，此时会出现不同的线程，加1后的值是一样的。
>
> 然后再刷回主内存，也就是前一个刷回去的也是1，后一个刷回去的也是1。导致数据丢失问题。
>
> volatile只保证了第四步是安全的，其他线程不可操作的，但是没有保证前三步，所以不能保证原子性。

> 从最终汇编语言从面来看，volatile使得每次将i进行了修改之后，增加了一个内存屏障lock addl $0x0,(%rsp)保证修改的值必须刷新到主内存才能进行内存屏障后续的指令操作。但是内存屏障之前的指令并不是原子的。
>
> 内存屏障是线程安全的,但是内存屏障之前的指令并不是.在某一时刻线程1将i的值load取出来，放置到cpu缓存中，然后再将此值放置到寄存器A中，然后A中的值自增1（寄存器A中保存的是中间值，没有直接修改i，因此其他线程并不会获取到这个自增1的值）。如果在此时线程2也执行同样的操作，获取值i==10,自增1变为11，然后马上刷入主内存。此时由于线程2修改了i的值，实时的线程1中的i==10的值缓存失效，重新从主内存中读取，变为11。接下来线程1恢复。将自增过后的A寄存器值11赋值给cpu缓存i。这样就出现了线程安全问题。

