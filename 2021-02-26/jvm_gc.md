# Java 中垃圾回收机制中如何判断对象需要回收？常见的 GC 回收算法有哪些？

## 什么是垃圾？

- 简单来说就是内存中已经不再被使用到的空间就是垃圾。

## 如何判断一个对象是否可以被回收？

### 引用计数法

- 通过引用计数器来判断一个对象是否可以回收。
- 每当有一个地方引用它，计数器+1
- 每当有一个引用失效时，计数器-1
- 任何时刻计算器为零的对象就是不可能再被使用的，那么这个对象就是可回收对象。
- 主流Java虚拟机已经弃用，因为很难解决对象之间相互循环引用的问题。

### 枚举根节点做可达性分析（根搜索路径）

- 为了解决引用计算器的循环引用问题，Java使用了可达性分析的方法
- 基本思路就是通过一系列名为“GC Roots”的对象作为起始点，从这个被称为GC Roots的对象开始向下搜索，如果一个对象到GC Roots没有任何引用链相连时，则说明此对象不可用，则可以被回收

#### Java中可以作为GC Roots的对象

- 虚拟机栈（栈帧中的局部变量区，也叫局部变量表）
- 方法区中的类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中JNI(Native方法)引用的对象

# 常见的GC回收算法

### 复制算法

- 将内存空间分成两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制在未被使用的内存块中，然后清除正在使用的的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收

### 标记-清除算法

- 当堆中的有效空间被耗尽的时候，就会停止整个程序，然后进行两项工作，第一项是标记，第二项是清除。
  - 标记：从引用根节点（gc roots）开始遍历，标记所有被引用的对象。一般在对象的Header中记录为可达对象。
  - 清除：对堆内存从头到尾进行遍历，如果发现某个对象在其Header中没有被标记为可达对象，则将其回收。

### 标记-压缩算法

- 标记-压缩算法等同于标记-清除算法后，再进行一次内存碎片整理，因此也可以称为标记-清除-压缩算法。
- 两者的本质差异在于标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的。

### 分代收集算法

- 分代收集算法实际上是上面算法的集合体，因为不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般是将Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收效率。
  - 新生代：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。一般使用复制算法则回收速度最快。
  - 老年代：区域较大，对象生命周期长，存活率高，回收没有新生代频繁。一般使用标记-清除算法与标记-整理算法的混合实现。